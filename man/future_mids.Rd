% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/future_mids.R
\name{future_mids}
\alias{future_mids}
\title{Parallelize \code{\link[mice:mice.mids]{`mice::mice.mids()`}}  Using \code{{future}}}
\usage{
future_mids(
  obj,
  newdata = NULL,
  maxit = 100L,
  minit = min(5L, maxit),
  quiet = FALSE,
  chunk_size = 1L,
  rhat_thresh = 1.05,
  rhat_max = 1.05,
  progressor = NULL,
  update_call = TRUE,
  ...
)
}
\arguments{
\item{obj}{A \code{mids} object, as created by
\code{\link[mice:mice]{mice::mice()}},
\code{\link[futuremice:future_mice]{future_mice()}},
or \code{future_mids()} (this function)}

\item{newdata}{An optional \code{data.frame} for which multiple imputations
are generated according to the model in \code{obj}.}

\item{maxit}{The number of additional Gibbs sampling iterations.}

\item{minit}{The minimum number of iterations to run. This is also the number
of iterations used to assess convergence. Convergence is defined as
\code{all(tail(rhat, minit) < rhat_max)}.}

\item{quiet}{Should convergence messages and warning be suppressed?}

\item{chunk_size}{The average number of chains per future. Differs from the
usual \code{{future}} parameter in that multiple chains ("chunks") will be
evaluated in a single call to \code{mice::mice()} if there is an integer \code{i}
such that \verb{1 < i <= chunk_size} and \code{m \%\% i == 0}.}

\item{rhat_max}{The R-hat threshold used to assess convergence.
Convergence is defined as \code{all(tail(rhat, minit) < rhat_max)}.}

\item{progressor}{An optional \code{\link[progressr]{progressor}}
function to signal progress updates. If supplied, you are responsible for
ensuring that the number of steps in the \code{progressor} is consistent with
the number of iterations performed in \code{future_mice()}.}

\item{update_call}{Should \code{mids$call} be set to new \code{future_mids()} call or
left unchanged?}

\item{...}{Named arguments that are passed down to the univariate imputation
functions.}
}
\value{
Returns an S3 object of class \code{\link[mice:mids-class]{mids}}
       (multiply imputed data set)
}
\description{
\code{future_mids()} is analogous to \code{mice::mice.mids()}, but parallelizes chains
using the \code{{furrr}} package and stops early if convergence is detected using
the R-hat statistic
(see the \code{\link[futuremice:future_mice]{future_mice()}} documentation
for details).
}
\examples{

# Run in parallel (just two cores to avoid hogging resources)
# Picking a number of workers that divides `m` evenly can help performance
future::plan("multisession", workers = pmin(2L, future::availableCores()))

# Run `mice::mice()`
# `m` and `maxit` are small here to keep runtime short
mids <- mice::mice(mice::nhanes, m = 2L, maxit = 1L)

# Run for additional iteration
mids <- future_mids(mids, maxit = 1L)

\dontrun{
# Run until convergence
mids <- future_mids(mids, maxit = 100L)
mids
}

# Reset future plan
future::plan("sequential")

}
