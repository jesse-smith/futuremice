<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content='future_mice() parallelizes chains in Multivariate Imputation using Chained
Equations (MICE) using the {furrr} package to create
futures for chains. Chains are also assessed for
convergence using the R-hat (potential scale reduction factor) statistic
computed by rstan::Rhat(); if the largest R-hat is
less than rhat_thresh for rhat_it iterations, the function returns early
(without completing maxit iterations). This can save a significant amount
of computation and manual convergence checking. However, a "good" R-hat is
not a substitute for assessing imputation quality.'><title>Parallelize `mice::mice()`  Using {future} — future_mice • futuremice</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Parallelize `mice::mice()`  Using {future} — future_mice"><meta property="og:description" content='future_mice() parallelizes chains in Multivariate Imputation using Chained
Equations (MICE) using the {furrr} package to create
futures for chains. Chains are also assessed for
convergence using the R-hat (potential scale reduction factor) statistic
computed by rstan::Rhat(); if the largest R-hat is
less than rhat_thresh for rhat_it iterations, the function returns early
(without completing maxit iterations). This can save a significant amount
of computation and manual convergence checking. However, a "good" R-hat is
not a substitute for assessing imputation quality.'><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">futuremice</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/jesse-smith/futuremice/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Parallelize <code>`mice::mice()`</code>  Using <code>{future}</code></h1>
      <small class="dont-index">Source: <a href="https://github.com/jesse-smith/futuremice/blob/HEAD/R/future_mice.R" class="external-link"><code>R/future_mice.R</code></a></small>
      <div class="d-none name"><code>future_mice.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>future_mice()</code> parallelizes chains in Multivariate Imputation using Chained
Equations (MICE) using the <code>{furrr}</code> package to create
<code>future</code>s for chains. Chains are also assessed for
convergence using the R-hat (potential scale reduction factor) statistic
computed by <code>rstan::Rhat()</code>; if the largest R-hat is
less than <code>rhat_thresh</code> for <code>rhat_it</code> iterations, the function returns early
(without completing <code>maxit</code> iterations). This can save a significant amount
of computation and manual convergence checking. However, a "good" R-hat is
not a substitute for assessing imputation quality.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">future_mice</span><span class="op">(</span>
  <span class="va">data</span>,
  <span class="va">predictorMatrix</span>,
  m <span class="op">=</span> <span class="fl">5L</span>,
  maxit <span class="op">=</span> <span class="fl">100L</span>,
  chunk_size <span class="op">=</span> <span class="fl">1L</span>,
  rhat_thresh <span class="op">=</span> <span class="fl">1.05</span>,
  rhat_it <span class="op">=</span> <span class="fl">3L</span>,
  seed <span class="op">=</span> <span class="cn">NULL</span>,
  <span class="va">...</span>
<span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>data</dt>
<dd><p>A data frame or a matrix containing the incomplete data.  Missing
values are coded as <code>NA</code>.</p></dd>
<dt>predictorMatrix</dt>
<dd><p>A numeric matrix of <code>length(blocks)</code> rows
and <code>ncol(data)</code> columns, containing 0/1 data specifying
the set of predictors to be used for each target column.
Each row corresponds to a variable block, i.e., a set of variables
to be imputed. A value of <code>1</code> means that the column
variable is used as a predictor for the target block (in the rows).
By default, the <code>predictorMatrix</code> is a square matrix of <code>ncol(data)</code>
rows and columns with all 1's, except for the diagonal.
Note: For two-level imputation models (which have <code>"2l"</code> in their names)
other codes (e.g, <code>2</code> or <code>-2</code>) are also allowed.</p></dd>
<dt>m</dt>
<dd><p>Number of multiple imputations. The default is <code>m=5</code>.</p></dd>
<dt>maxit</dt>
<dd><p>A scalar giving the maximum number of iterations. <code>future_mice()</code>
will use less than <code>maxit</code> iterations if convergence criteria are met.</p></dd>
<dt>chunk_size</dt>
<dd><p>The average number of chains per future. Differs from the
usual <code>{future}</code> parameter in that multiple chains ("chunks") will be
evaluated in a single call to <code>mice::mice()</code> if <code>chunk_size</code> and <code>m</code> share
a greatest common denominator higher than <code>1</code>.</p></dd>
<dt>rhat_thresh</dt>
<dd><p>The R-hat threshold used to assess convergence.
Convergence is defined as <code>all(tail(rhat, rhat_it) &lt; rhat_thresh)</code>.</p></dd>
<dt>rhat_it</dt>
<dd><p>The number of iterations used to assess convergence.
Convergence is defined as <code>all(tail(rhat, rhat_it) &lt; rhat_thresh)</code>.</p></dd>
<dt>seed</dt>
<dd><p>Seed for random number generation; either a length 1 integer or
<code>NULL</code>. This seed is not used directly in <code>mice::mice()</code>; instead, it is
used to generate separate RNG streams for each <code>future</code> using the
parallel-safe L'Ecuyer-CMRG algorithm.</p></dd>
<dt>...</dt>
<dd><p>Arguments passed on to <code>mice::mice</code></p><dl><dt><code>method</code></dt>
<dd><p>Can be either a single string, or a vector of strings with
length <code>length(blocks)</code>, specifying the imputation method to be
used for each column in data. If specified as a single string, the same
method will be used for all blocks. The default imputation method (when no
argument is specified) depends on the measurement level of the target column,
as regulated by the <code>defaultMethod</code> argument. Columns that need
not be imputed have the empty method <code>""</code>. See details.</p></dd>

    <dt><code>ignore</code></dt>
<dd><p>A logical vector of <code>nrow(data)</code> elements indicating
which rows are ignored when creating the imputation model. The default
<code>NULL</code> includes all rows that have an observed value of the variable
to imputed. Rows with <code>ignore</code> set to <code>TRUE</code> do not influence the
parameters of the imputation model, but are still imputed. We may use the
<code>ignore</code> argument to split <code>data</code> into a training set (on which the
imputation model is built) and a test set (that does not influence the
imputation model estimates).
Note: Multivariate imputation methods, like <code>mice.impute.jomoImpute()</code>
or <code>mice.impute.panImpute()</code>, do not honour the <code>ignore</code> argument.</p></dd>

    <dt><code>where</code></dt>
<dd><p>A data frame or matrix with logicals of the same dimensions
as <code>data</code> indicating where in the data the imputations should be
created. The default, <code>where = is.na(data)</code>, specifies that the
missing data should be imputed. The <code>where</code> argument may be used to
overimpute observed data, or to skip imputations for selected missing values.</p></dd>

    <dt><code>blocks</code></dt>
<dd><p>List of vectors with variable names per block. List elements
may be named to identify blocks. Variables within a block are
imputed by a multivariate imputation method
(see <code>method</code> argument). By default each variable is placed
into its own block, which is effectively
fully conditional specification (FCS) by univariate models
(variable-by-variable imputation). Only variables whose names appear in
<code>blocks</code> are imputed. The relevant columns in the <code>where</code>
matrix are set to <code>FALSE</code> of variables that are not block members.
A variable may appear in multiple blocks. In that case, it is
effectively re-imputed each time that it is visited.</p></dd>

    <dt><code>visitSequence</code></dt>
<dd><p>A vector of block names of arbitrary length, specifying the
sequence of blocks that are imputed during one iteration of the Gibbs
sampler. A block is a collection of variables. All variables that are
members of the same block are imputed
when the block is visited. A variable that is a member of multiple blocks
is re-imputed within the same iteration.
The default <code>visitSequence = "roman"</code> visits the blocks (left to right)
in the order in which they appear in <code>blocks</code>.
One may also use one of the following keywords: <code>"arabic"</code>
(right to left), <code>"monotone"</code> (ordered low to high proportion
of missing data) and <code>"revmonotone"</code> (reverse of monotone).
<em>Special case</em>: If you specify both <code>visitSequence = "monotone"</code> and
<code>maxit = 1</code>, then the procedure will edit the <code>predictorMatrix</code>
to conform to the monotone pattern. Realize that convergence in one
iteration is only guaranteed if the missing data pattern is actually
monotone. The procedure does not check this.</p></dd>

    <dt><code>formulas</code></dt>
<dd><p>A named list of formula's, or expressions that
can be converted into formula's by <code>as.formula</code>. List elements
correspond to blocks. The block to which the list element applies is
identified by its name, so list names must correspond to block names.
The <code>formulas</code> argument is an alternative to the
<code>predictorMatrix</code> argument that allows for more flexibility in
specifying imputation models, e.g., for specifying interaction terms.</p></dd>

    <dt><code>blots</code></dt>
<dd><p>A named <code>list</code> of <code>alist</code>'s that can be used
to pass down arguments to lower level imputation function. The entries
of element <code>blots[[blockname]]</code> are passed down to the function
called for block <code>blockname</code>.</p></dd>

    <dt><code>post</code></dt>
<dd><p>A vector of strings with length <code>ncol(data)</code> specifying
expressions as strings. Each string is parsed and
executed within the <code>sampler()</code> function to post-process
imputed values during the iterations.
The default is a vector of empty strings, indicating no post-processing.
Multivariate (block) imputation methods ignore the <code>post</code> parameter.</p></dd>

    <dt><code>defaultMethod</code></dt>
<dd><p>A vector of length 4 containing the default
imputation methods for 1) numeric data, 2) factor data with 2 levels, 3)
factor data with &gt; 2 unordered levels, and 4) factor data with &gt; 2
ordered levels. By default, the method uses
<code>pmm</code>, predictive mean matching (numeric data) <code>logreg</code>, logistic
regression imputation (binary data, factor with 2 levels) <code>polyreg</code>,
polytomous regression imputation for unordered categorical data (factor &gt; 2
levels) <code>polr</code>, proportional odds model for (ordered, &gt; 2 levels).</p></dd>

    <dt><code>printFlag</code></dt>
<dd><p>If <code>TRUE</code>, <code>mice</code> will print history on console.
Use <code>print=FALSE</code> for silent computation.</p></dd>

    <dt><code>data.init</code></dt>
<dd><p>A data frame of the same size and type as <code>data</code>,
without missing data, used to initialize imputations before the start of the
iterative process.  The default <code>NULL</code> implies that starting imputation
are created by a simple random draw from the data. Note that specification of
<code>data.init</code> will start all <code>m</code> Gibbs sampling streams from the same
imputation.</p></dd>

  
</dl></dd>
</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>Returns an S3 object of class <code>mids</code>       (multiply imputed data set)</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>MICE is a method for creating multiple imputations (replacement values) for
multivariate missing data. The method is based on Fully Conditional
Specification (FCS), where each incomplete varaible is imputed by a separate
model. The MICE algorithm can impute mixes of continuous, binary, unordered
categorical and ordered categorical data. In addition, MICE can impute
continuous two-level data and maintain consistency between imputations by
means of passive imputation and post-processing. Many diagnostic plots are
implemented to inspect the quality of the imputations. See the
<code>mice::mice()</code> function and the vignettes on the
<a href="https://amices.org/mice/" class="external-link"><code>{mice}</code></a> package website for details.</p>
    </div>

  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Jesse Smith.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.3.</p>
</div>

    </footer></div>

  

  

  </body></html>

